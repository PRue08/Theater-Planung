```html
<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Theater Planung</title>
<style>
/* Globale Stile */
body {
    margin: 0;
    font-family: system-ui, sans-serif; /* Verbesserte Schriftart */
    background: #f4f5f7;
    line-height: 1.6; /* Bessere Lesbarkeit */
}

/* Navigation */
nav {
    background: #fff;
    padding: 10px;
    display: flex;
    gap: 10px;
    align-items: center;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Leichter Schatten f√ºr Tiefe */
}

nav a {
    padding: 6px 10px;
    border-radius: 6px;
    text-decoration: none;
    color: #000;
    transition: background-color 0.3s ease; /* Sanfter √úbergangseffekt */
}

nav a.active,
nav a:hover {
    background: #ddd;
}

/* Karten (Sections) */
.card {
    background: #fff;
    border: 1px solid #ccc;
    border-radius: 10px;
    padding: 20px; /* Erh√∂hter Padding f√ºr mehr Platz */
    margin: 10px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); /* Leichter Schatten */
}

/* Tabellen */
table {
    border-collapse: collapse;
    width: 100%;
    margin-bottom: 15px; /* Abstand unter der Tabelle */
}

th,
td {
    border: 1px solid #ccc;
    padding: 8px; /* Erh√∂hter Padding */
    text-align: center;
}

th {
    background-color: #f0f0f0; /* Hintergrundfarbe f√ºr Tabellenkopf */
    font-weight: bold;
}

td {
    min-width: 60px;
}

td[contenteditable] {
    background: #fafafa;
}

/* Versteckte Elemente */
.hidden {
    display: none;
}

/* Buttons */
.btn {
    padding: 8px 12px; /* Angepasster Padding */
    border: 1px solid #ccc;
    border-radius: 6px;
    background: #eee;
    cursor: pointer;
    transition: background-color 0.3s ease; /* Sanfter √úbergangseffekt */
}

.btn:hover {
    background-color: #ddd;
}

/* Formularelemente */
input,
textarea {
    width: 100%;
    padding: 8px; /* Padding f√ºr Input-Felder */
    box-sizing: border-box;
    margin-bottom: 10px; /* Abstand unter den Input-Feldern */
    border: 1px solid #ccc;
    border-radius: 4px;
}

/* B√ºhnenbild-Miniaturansichten */
.stage-thumb {
    width: 100px;
    height: 100px;
    border: 1px solid #999;
    background: #eee;
    cursor: pointer;
    position: relative;
    overflow: hidden; /* Stellt sicher, dass der Inhalt nicht √ºberl√§uft */
}

.stage-thumb img {
    width: 100%;
    height: 100%;
    object-fit: cover; /* F√ºllt den Container ohne Verzerrung */
}

.stage-thumb span {
    position: absolute;
    top: 2px;
    left: 2px;
    font-size: 11px;
    background-color: rgba(255, 255, 255, 0.7); /* Halbtransparenter Hintergrund */
    padding: 2px;
    border-radius: 3px;
}

/* B√ºhnenbild-Modal */
#stageModal {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000; /* Stellt sicher, dass es √ºber allem liegt */
}

#stageModal.hidden {
    display: none;
}

#stageModal .box {
    background: #fff;
    padding: 20px; /* Erh√∂hter Padding */
    border-radius: 10px;
    max-width: 90%; /* Maximale Breite f√ºr responsives Design */
    max-height: 90%; /* Maximale H√∂he */
    overflow: auto; /* F√ºgt Scrollbalken hinzu, wenn der Inhalt zu gro√ü ist */
}

/* Canvas */
canvas {
    border: 1px solid #000;
    background: #fff;
    touch-action: none;
}

/* Rollen- und Szenenkarten */
.roleCard,
.sceneCard {
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 12px; /* Angepasster Padding */
    margin: 8px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05); /* Leichter Schatten */
}

/* Flexbox-Layout f√ºr B√ºhnenbilder */
#stageContainer {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}
</style>
</head>
<body>

<nav>
<strong>üé≠ Theater</strong>
<a href="#" data-view="overview" class="active">√úbersicht</a>
<a href="#" data-view="roles">Rollen</a>
<a href="#" data-view="scenes">Szenen</a>
</nav>

<main>

<section id="overview" class="card">
<h2>√úbersicht</h2>
<div>
<button id="addRowO" class="btn">+ Zeile</button>
<button id="delRowO" class="btn">- Zeile</button>
<button id="addColO" class="btn">+ Spalte</button>
<button id="delColO" class="btn">- Spalte</button>
<button id="colorCell" class="btn">üé® Zelle f√§rben</button>
</div>
<table id="overviewTable"></table>
</section>

<section id="roles" class="card hidden">
<h2>Rollen</h2>
<div id="rolesList"></div>
<button id="addRole" class="btn">+ Rolle hinzuf√ºgen</button>
</section>

<section id="scenes" class="card hidden">
<h2>Szenen</h2>
<div id="sceneList"></div>
<button id="addScene" class="btn">+ Szene hinzuf√ºgen</button>
<hr>
<h3>B√ºhnenbilder</h3>
<div id="stageContainer" style="display:flex;gap:10px;flex-wrap:wrap"></div>
<button id="addStage" class="btn">+ B√ºhnenbild</button>
<button id="delStage" class="btn">- B√ºhnenbild</button>
</section>

</main>

<div id="stageModal" class="hidden">
<div class="box">
<div>
<button id="pen">‚úèÔ∏è</button>
<button id="eraser">üßΩ</button>
<input id="color" type="color" value="#000000">
<input id="size" type="range" min="1" max="20" value="4">
<button id="person">üë§</button>
<button id="chair">ü™ë</button>
<button id="boxIcon">üì¶</button>
<button id="rectTool">‚¨õ K√§stchen</button>
<button id="deleteRect">üóë L√∂schen</button>
<button id="zoomIn">‚ûï</button>
<button id="zoomOut">‚ûñ</button>
<button id="deleteItem">üóë Icon l√∂schen</button>
    
</div>
<canvas id="canvas" width="900" height="900"></canvas>
<button id="close">Schlie√üen</button>
</div>
</div>

<script>
/* Navigation */
document.querySelectorAll("nav a").forEach(a=>{
  a.onclick = e => {
    e.preventDefault();
    document.querySelectorAll("nav a").forEach(x=>x.classList.remove("active"));
    a.classList.add("active");
    document.querySelectorAll("main section").forEach(s=>s.classList.add("hidden"));
    document.getElementById(a.dataset.view).classList.remove("hidden");
  };
});

/* Daten */
let data = JSON.parse(localStorage.theater || '{"overview":[[]],"roles":[],"scenes":[]}');
function save(){ localStorage.theater = JSON.stringify(data) }

/* √úbersicht Tabelle */
let selected=null;
function drawOverview(){
  let t=document.getElementById("overviewTable"); t.innerHTML="";
  data.overview.forEach((r,i)=>{
    let tr=document.createElement("tr");
    r.forEach((c,j)=>{
      let td=document.createElement("td");
      td.contentEditable=true;
      td.innerText = c.text||"";
      td.style.background = c.color||"";
      td.onclick = () => selected=td;
      td.oninput = () => { c.text=td.innerText; save(); };
      tr.appendChild(td);
    });
    t.appendChild(tr);
  });
}
if(data.overview.length===0){
  data.overview = Array.from({length:33},()=>Array.from({length:26},()=>({text:""})));
}
drawOverview();

addRowO.onclick=()=>{ data.overview.push(Array.from({length:data.overview[0].length},()=>({text:""}))); save(); drawOverview(); }
delRowO.onclick=()=>{ data.overview.pop(); save(); drawOverview(); }
addColO.onclick=()=>{ data.overview.forEach(r=>r.push({text:""})); save(); drawOverview(); }
delColO.onclick=()=>{ data.overview.forEach(r=>r.pop()); save(); drawOverview(); }
colorCell.onclick=()=>{ if(selected) selected.style.background = selected.style.background ? "" : "#ffe066"; }

/* Rollen */
function renderRoles(){
  rolesList.innerHTML="";
  data.roles.forEach((r,i)=>{
    let d=document.createElement("div");
    d.className="roleCard";
    d.innerHTML=`
      <input placeholder="Rolle" value="${r.name||""}">
      <input placeholder="Darsteller" value="${r.actor||""}">
      <textarea placeholder="Szenen / Auftritte">${r.scenes||""}</textarea>
      <input placeholder="Kost√ºm" value="${r.costume||""}">
      <input placeholder="Requisiten" value="${r.props||""}">
      <textarea placeholder="Notizen">${r.notes||""}</textarea>
      <input type="file">
      <button class="btn delete-role-btn">‚ùå Rolle l√∂schen</button>
    `;
    // Verwende Event Delegation, um das Problem mit mehrfach gebundenen Events zu vermeiden
    d.querySelector(".delete-role-btn").addEventListener('click', (e) => {
        e.preventDefault(); // Verhindert das Standardverhalten des Buttons
        data.roles.splice(i,1);
        save();
        renderRoles();
    });
    rolesList.appendChild(d);
  });
}
addRole.onclick=()=>{ data.roles.push({}); save(); renderRoles(); };
renderRoles();

/* Szenen */
let currentScene = null;
function renderScenes(){
  sceneList.innerHTML="";
  data.scenes.forEach((s,i)=>{
    let d=document.createElement("div");
    d.className="sceneCard";
    d.innerHTML=`
      <h4>Szene ${i+1}</h4>
      <textarea placeholder="Licht">${s.light||""}</textarea>
      <textarea placeholder="Musik">${s.music||""}</textarea>
      <textarea placeholder="Charaktere">${s.chars||""}</textarea>
      <textarea placeholder="Choreografie">${s.choreo||""}</textarea>
      <textarea placeholder="Gegenst√§nde">${s.props||""}</textarea>
      <input type="file">
      <button class="btn delete-scene-btn">Szene l√∂schen</button>
    `;
    d.addEventListener('click', () => { currentScene = i; renderStages(); });

       // Verwende Event Delegation, um das Problem mit mehrfach gebundenen Events zu vermeiden
       d.querySelector(".delete-scene-btn").addEventListener('click', (e) => {
            e.stopPropagation(); // Verhindert, dass der Klick auf das √§u√üere div feuert
            e.preventDefault(); // Verhindert das Standardverhalten des Buttons
            data.scenes.splice(i,1);
            save();
            renderScenes();
            stageContainer.innerHTML="";
        });
    sceneList.appendChild(d);
  });
}
addScene.onclick = () => { data.scenes.push({stages:[]}); save(); renderScenes(); };
renderScenes();

/* B√ºhnenbilder */
function renderStages() {
    stageContainer.innerHTML = "";
    if (currentScene === null || !data.scenes[currentScene] || !data.scenes[currentScene].stages) {
        return;
    }

    data.scenes[currentScene].stages.forEach((stageData, index) => {
        const stageThumb = document.createElement("div");
        stageThumb.className = "stage-thumb";
        stageThumb.innerHTML = `
            <span>B√ºhne ${index + 1}</span>
            <img src="${stageData}" alt="B√ºhnenbild ${index + 1}">
        `;
        stageThumb.addEventListener('click', () => openStage(index));
        stageContainer.appendChild(stageThumb);
    });
}

addStage.onclick = () => {
    if (currentScene === null) {
        alert("Bitte zuerst eine Szene ausw√§hlen üëÜ");
        return;
    }

    // Neues leeres B√ºhnenbild erstellen
    const emptyCanvas = document.createElement("canvas");
    emptyCanvas.width = 900;
    emptyCanvas.height = 900;
    const emptyCtx = emptyCanvas.getContext("2d");
    emptyCtx.fillStyle = "#fff";
    emptyCtx.fillRect(0, 0, 900, 900);
    const dataUrl = emptyCanvas.toDataURL();

    // In die Daten einf√ºgen
    if (!data.scenes[currentScene].stages) {
        data.scenes[currentScene].stages = []; // Initialisiert das Array, falls es nicht existiert
    }
    data.scenes[currentScene].stages.push(dataUrl);
    save();

    // Neu rendern
    renderStages();
};

delStage.onclick = () => {
    if (currentScene === null) {
        alert("Bitte zuerst eine Szene ausw√§hlen üëÜ");
        return;
    }

    if (!data.scenes[currentScene].stages || data.scenes[currentScene].stages.length === 0) {
        alert("Keine B√ºhnenbilder zum L√∂schen vorhanden.");
        return;
    }

    data.scenes[currentScene].stages.pop(); // L√∂scht das letzte B√ºhnenbild
    save();
    renderStages();
};

/* ===== Canvas Setup ===== */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
ctx.lineCap = "round";
ctx.font = "28px serif";

/* Tools */
const pen = document.getElementById("pen");
const eraser = document.getElementById("eraser");
const person = document.getElementById("person");
const chair = document.getElementById("chair");
const boxIcon = document.getElementById("boxIcon");
const rectTool = document.getElementById("rectTool");
const deleteRect = document.getElementById("deleteRect");
const deleteIcon = document.getElementById("deleteItem");
const zoomIn = document.getElementById("zoomIn");
const zoomOut = document.getElementById("zoomOut");
const size = document.getElementById("size");
const color = document.getElementById("color");

/* Canvas State */
let scale = 1, tool = "pen", drawing = false;
let paths = [], boxes = [], icons = [];
let dragBox = null, resizeBox = null, selectedBox = null;
let selectedIcon = null, currentPath = null, activeStage = null;

/* ===== Canvas Funktionen ===== */
function resizeCanvas(){
  const max = Math.min(window.innerWidth*0.9, window.innerHeight*0.7);
  canvas.width = max;
  canvas.height = max;
}

function openStage(i){
  activeStage = i;
  resizeCanvas();
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const imgData = data.scenes[currentScene].stages[i];
  if(imgData){
    const img = new Image();
    img.onload = () => redraw(img); // Bild an redraw √ºbergeben
    img.src = imgData;
  } else {
    redraw();
  }

  stageModal.classList.remove("hidden");
}

/* ===== Pointer Events ===== */
canvas.onpointerdown = e => {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / scale;
  const y = (e.clientY - rect.top) / scale;

  console.log("Tool:", tool); // Debugging

  // **Zuerst pr√ºfen, ob gel√∂scht werden soll**
  if (tool === "deleteIcon") {
    selectedIcon = icons.find(i => x >= i.x && x <= i.x + i.size && y >= i.y && y <= i.y + i.size);
    if (selectedIcon) {
      icons = icons.filter(i => i !== selectedIcon);
      selectedIcon = null;
      redraw();
      return; // Wichtig: Funktion hier verlassen, wenn gel√∂scht wurde
    } else {
      console.log("Kein Icon zum L√∂schen ausgew√§hlt.");
      return; // Wichtig: Funktion hier verlassen, wenn nichts zu l√∂schen war
    }
  }

  // **Dann pr√ºfen, ob ein Icon ausgew√§hlt werden soll (zum Verschieben)**
  selectedIcon = icons.find(i => x >= i.x && x <= i.x + i.size && y >= i.y && y <= i.y + i.size);

  console.log("Selected Icon:", selectedIcon); // Debugging

  if (selectedIcon) {
    // **Verschiebe-Modus aktivieren**
    drawing = false; // Zeichnen deaktivieren
    dragBox = null; // Box-Verschiebung deaktivieren
    resizeBox = null; // Box-Gr√∂√üen√§nderung deaktivieren
    return; // Wichtig: Funktion hier verlassen, um Verschiebung zu starten
  }

  // **Wenn kein Icon ausgew√§hlt wurde, andere Aktionen ausf√ºhren**
  selectedBox = boxes.find(b => x > b.x && x < b.x + b.w && y > b.y && y < b.y + b.h);
  if (dragBox) {
    selectedBox = dragBox;
    if (x > dragBox.x + dragBox.w - 10 && y > dragBox.y + dragBox.h - 10) {
      resizeBox = dragBox;
    }
    return;
  }
  selectedBox = null;

  // Neues Icon platzieren
  if (tool === "person" || tool === "chair" || tool === "box") {
    const char = tool === "person" ? "üë§" : tool === "chair" ? "ü™ë" : "üì¶";
    icons.push({ char, x, y, size: parseInt(size.value) * 6, type: tool });
    redraw();
    return;
  }

  // Neues K√§stchen platzieren
  if (tool === "rect") {
    boxes.push({ x: x - 40, y: y - 30, w: 80, h: 60 });
    redraw();
    return;
  }

  // Freihand zeichnen
  if (tool === "pen" || tool === "eraser") {
    drawing = true;
    currentPath = { tool, color: color.value, size: parseInt(size.value), points: [{ x, y }] };
    paths.push(currentPath);
  }
};

canvas.onpointermove = e => {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / scale;
  const y = (e.clientY - rect.top) / scale;

  // **Icon verschieben**
  if (selectedIcon) {
    selectedIcon.x = x - selectedIcon.size/2; // Zentriere das Icon unter dem Cursor
    selectedIcon.y = y - selectedIcon.size/2; // Zentriere das Icon unter dem Cursor
    redraw();
    return;
  }

  if (dragBox && !resizeBox) {
    dragBox.x = x - dragBox.w / 2;
    dragBox.y = y - dragBox.h / 2;
    redraw();
    return;
  }
  if (resizeBox) {
    resizeBox.w = Math.max(20, x - resizeBox.x);
    resizeBox.h = Math.max(20, y - resizeBox.y);
    redraw();
    return;
  }
  if (drawing) {
    currentPath.points.push({ x, y });
    redraw();
  }
};

canvas.onpointerup = () => {
  drawing = false;
  dragBox = null;
  resizeBox = null;
  selectedBox = null;
  // **Wichtig: selectedIcon hier auch auf null setzen, um die Verschiebung zu beenden**
  selectedIcon = null;
};

/* ===== Redraw Funktion ===== */
function redraw(bgImg=null){
  ctx.setTransform(scale,0,0,scale,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(bgImg) ctx.drawImage(bgImg,0,0,canvas.width,canvas.height);

  // Freihand
  paths.forEach(p=>{
    ctx.beginPath();
    ctx.strokeStyle=p.color;
    ctx.lineWidth=p.size;
    ctx.globalCompositeOperation=p.tool==="eraser"?"destination-out":"source-over";
    p.points.forEach((pt,i)=> i?ctx.lineTo(pt.x,pt.y):ctx.moveTo(pt.x,pt.y));
    ctx.stroke();
  });
  ctx.globalCompositeOperation="source-over";

  // Boxen
  boxes.forEach(b=>{
    ctx.strokeStyle="#333"; ctx.lineWidth=2;
    ctx.strokeRect(b.x,b.y,b.w,b.h);
    ctx.fillStyle="#999"; ctx.fillRect(b.x+b.w-10,b.y+b.h-10,10,10);
  });

  // Icons
  icons.forEach(i=>{
    ctx.font=i.size+"px serif";
    ctx.fillText(i.char,i.x,i.y);
  });
}

/* ===== Buttons ===== */
pen.onclick = () => tool="pen";
eraser.onclick = () => tool="eraser";
person.onclick = () => tool="person";
chair.onclick = () => tool="chair";
boxIcon.onclick = () => tool="box";
rectTool.onclick = () => tool="rect";
deleteRect.onclick = () => { boxes.pop(); redraw(); };
deleteIcon.onclick = () => tool="deleteIcon";
zoomIn.onclick = () => { scale*=1.1; redraw(); };
zoomOut.onclick = () => { scale/=1.1; redraw(); };

/* ===== Close Button ===== */
document.getElementById("close").onclick = () => {
  data.scenes[currentScene].stages[activeStage] = canvas.toDataURL();
  save();
  renderStages();
  stageModal.classList.add("hidden");
};

// Initiales Rendern der B√ºhnenbilder, falls eine Szene bereits ausgew√§hlt ist
if (data.scenes.length > 0) {
    currentScene = 0; // W√§hlt die erste Szene aus
    renderStages();
}
</script>
</body>
</html>
```